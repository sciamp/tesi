\small
\chapter*{Appendice}
\subsection*{ydiagram.mac}
\begin{alltt}
\footnotesize
defstruct (ydiagram (rows));

\emph{new\_ydiagram\_safe} (l) := block (
  [yd],
  yd : new (ydiagram (sort (l, 'orderlessp))),
  return (yd));

\emph{ydiagramp} (d) := listp (d@rows) and d@rows = sort (d@rows, 'orderlessp);

\emph{remove\_diagram\_column} (r, l) := 
if emptyp (r) then return (l)
else block (
  l : append ([length (r)], l),
  r : r-1,
  r : delete (0, r),
  return (\emph{remove\_diagram\_column} (r, l)));

/* D is a Young diagram */
\emph{ydiagram\_transpose} (D) := block (
  [l,r],
  r : D@rows,
  l : \emph{remove\_diagram\_column} (r, []),
  return (\emph{new\_ydiagram\_safe} (l)));

/* d should be the (new\_ydiagram\_safe (d))@rows */
\emph{ydiagram\_transpose\_rows} (d) := \emph{remove\_diagram\_column} (d, []);

\emph{ydiagram\_size} (d) := block (
  [size],
  size : 0,
  for i : 1 thru length (d@rows) do size : size+d@rows[i],
  return (size));
\end{alltt}
\small

\subsection*{yshape.mac}
\begin{alltt}
\footnotesize
infix ("li=");

"li=" (ll,l) := block (
  ret : true,
  for i : 1 thru length (l) do if length (ll[i]) # l[i] then ret : false,
  return (ret));

\emph{yshapep} (t,d) :=
if (ydiagramp (d) and ytableaup (t)) then block (
  ret : false,
  if (length (t@word) = length (d@rows)) and (t@word li= d@rows) then ret : true,
  return (ret))
else false;

/* returns the number of boxes in a diagram */
\emph{yshapesize} (U) := sum (U@rows[i], i, 1, length (U@rows));

/* each time this function is called it attaches only one box in every */
/* possible position of the current diagram */
/* level should be 1 */
/* nextl should be [] */
\emph{attach\_box} (shape, ins, level, nextl) :=
if (ins > 0) then block (
  [],
  if (level <= length (shape)) then block (
    [],
    if (level > 1) then block (
      [],
      if (shape[level - 1] > shape[level]) then block ( /* we can attach at this level */
        [curr],
        curr : [copylist (shape), ins - 1],
        curr[1][level] : shape[level] + 1,
        nextl : append (nextl, [curr])),
      return (\emph{attach\_box} (shape, ins, level + 1, nextl)))
    else block (
      [curr],
      curr : [copylist (shape), ins - 1],
      curr[1][1] : shape[1] + 1,
      return (\emph{attach\_box} (shape, ins, level + 1, append (nextl, [curr])))))
  else if (level = length (shape) + 1) then return (
    \emph{attach\_box} (shape, ins, level + 1, append (nextl, [[append (shape, [1]), ins - 1]])))
  else return (nextl))
else nextl;

/* given two words of two diagrams e and u, returns a list with all possible */
/* diagrams d fitting V=TU where V is a tableaux of shape d, T and U are tableaux */
/* of shape e and u respectively, and containing e. */
/* ds should be [[e,yshapesize(u)]] */
/* e is a reversed words */
\emph{yshape\_product} (ds) :=
if (not every (lambda ([x], is (x[2] = 0)), ds)) then block (
  [curr,nextl],
  curr : first (ds),      /* we can use pop from */
  ds : delete (curr, ds), /* basic.mac instead. */
  nextl : \emph{attach\_box} (curr[1], curr[2], 1, []),
  ds : append (ds, nextl),
  return (\emph{yshape\_product} (ds)))
else ds; /* we're done */
\end{alltt}
\small

\subsection*{utils.mac}
\begin{alltt}
\footnotesize
infix (">>=");

/* true if e is bigger than every element of l */
">>=" (e,l) := every (lambda ([x], x <= e), l);

\emph{backpop}(l)::=(symbolcheck(l),buildq([l],prog1(last(l),l:rest(l, -1))));

\emph{lengthlessp} (l1, l2) := (length (l1) < length (l2));

/* Given a word (of fixed length n) in the alphabet {1,2,...,m} of */
/* integers returns the next one in the lexicographical order. */
/* If the given word is the last one (i.e. [m,m,...,m]) returns [1,1,...,1] */
\emph{next\_lex\_word} (l, n, m) :=
if n > 0 then block (
  if l[n] < m then block (
    l[n] : l[n]+1,
    return (l))
  else block (
    l[n] : 1,
    l : \emph{next\_lex\_word} (l, n-1, m)))
else return (l);
\end{alltt}
\small

\subsection*{ytableau.mac}
\begin{alltt}
\footnotesize
defstruct (ytableau (word));

\emph{new\_ytableau\_safe} (l) := block (
  [w],
  w : \emph{ytableauwordp} (l),
  yt : false,
  if listp (w) then yt : new (ytableau (w)),
  yt);

/* let's check if the list w is a suitable word for some tableau */
\emph{ytableauwordp} (w) :=
if listp (w) then block (
  rows : makelist (),
  for i:1 unless emptyp (w) do block (
    top : pop (w),
    /* errcatch returns an empty list in case of error, so */
    /* if some rows exist we get the list containing a list which represents */
    /* the last row, if rows is empty we get an empty list (i.e. a new row!) */
    lastrow : errcatch (\emph{backpop} (rows)),
    if not emptyp (lastrow) then lastrow : first (lastrow),
    if top >>= lastrow then block (
      lastrow : append (lastrow, makelist (top)),
      rows : append (rows, makelist (lastrow)))
    else block (
      rows : append (rows, makelist (lastrow)),
      rows : append (rows, makelist (makelist (top))))),
  if rows = sort (rows, 'lengthlessp) then rows
  else false
) else false;

\emph{ytableaup} (t) :=
if listp (t@word) then block (
  [l,w],
  l : makelist (),
  for i : 1 thru length (t@word) do
  if listp (t@word[i]) then l : append (l, t@word[i]),
  w : \emph{ytableauwordp} (l),
  if listp (w) then return (true))
else false;

/* l should be a tableau word, if given as a string */
/* as i'm not always in the mood for entering a list of integers! */
/* should be map ('parse\_string, charlist ("5644623551223")) */
\emph{ytableau\_from\_word} (l,t) :=
if ((not emptyp (l)) and (not emptyp (t))) then block (
  if (last (t[1])) <= l[1] then block (
    t[1] : append (t[1], [l[1]]),
    return (\emph{ytableau\_from\_word} (rest (l, 1), t)))
  else block (
    t : append ([[l[1]]], t),
    return (\emph{ytableau\_from\_word} (rest (l, 1), t))))
else if (not emptyp (l)) then block (
  t : [[l[1]]],
  return (\emph{ytableau\_from\_word} (rest (l, 1), t)))
else reverse (t);

/* we could use flatten, this is the implementation */
/* of the algorithm from W.Fulton 'Young Tableaux' */
/* l should be [], t is a tableau word */
\emph{word\_from\_ytableau} (l, t) :=
if (not emptyp (t)) then \emph{word\_from\_ytableau} (append (l, t[1]), rest (t, 1))
else l;

\emph{ytableau\_bump} (T, x) := block (
  appended : false,
  for i : length (T@word) step -1 while (i > 0 and not appended) do block (
    bumped : false,
    if x < last (T@word[i]) then block (
      for j : 1 unless (j>length (T@word[i])) or bumped do
      if x < (T@word[i])[j] then block (
        tmp : x,
        x : (T@word[i])[j],
        (T@word[i])[j] : tmp,
        bumped : true))
    else block (
      T@word[i] : append (T@word[i], [x]),
      appended : true)),
  if not appended then block ( 
    w : T@word,
    T@word : push ([x], w)),
  return (T));

/* rb should be [r, x] where x is the element that is being bumped */
/* in the row r */
/* i should be length (r) */
/* rec\_bump\_row returns [bumped\_row, next\_x] or [append (r,[x]), 0]  */
\emph{rec\_bump\_row} (r, x, i) :=
if (x >= last (r)) then [append (r, [x]), 0] /* r[i] <= r[i+1] */
else if ((i > 0) and (x < r[i])) then \emph{rec\_bump\_row} (r, x, i-1)
else block (
  [next\_x],
  next\_x : r[i+1],
  r[i+1] : x,
  return ([r, next\_x]));

/* t should be T@word */
/* i should be length (t) */
\emph{rec\_ytableau\_word\_bump} (t, x, i) :=
if (x > 0) then block (
  [],
  if (i > 0) then block (
    [next\_b],
    next\_b : \emph{rec\_bump\_row} (t[i], x, length (t[i])),
    t[i] : next\_b[1],
    return (\emph{rec\_ytableau\_word\_bump} (t, next\_b[2], i-1)))
  else return (append ([[x]], t)))
else t;

/* T should be a tableau, x a positive integer */
\emph{recursive\_ytableau\_bump} (T, x) := new (
  ytableau (\emph{rec\_ytableau\_word\_bump} (T@word, x, length (T@word))));

/* (i,j) should be (1,1) */
\emph{rec\_ytableau\_word\_prod} (t, u, u\_len, i, j) :=
if ((i <= u\_len) and (j <= length (u[i]))) then \emph{rec\_ytableau\_word\_prod} (
  \emph{rec\_ytableau\_word\_bump} (t, u[i][j], length (t)), u, u\_len, i, j+1)
else if ((i <= u\_len) and (j > length (u[i]))) then
  \emph{rec\_ytableau\_word\_prod} (t, u, u\_len, i+1, 1)
else t;

/* s should be the word of a skew tableau */
/* s\_len should be length(s) */
/* (i,j) should be (1,1) unless YOU KNOW WHAT YOU'RE DOING! */
\emph{next\_inner\_corner} (s, s\_len, i, j) :=
if (i <= s\_len) then block (
  [],
  /* no inner corners in this line */
  if (s[i][1] > 0) then return (\emph{next\_inner\_corner} (s, s_len, i+1, 1))
  else if (j < length (s[i]) and s[i][j+1] > 0) then return ([i, j]) /* we got an inner corner */
  else if (j < length (s[i]) and s[i][j+1] = 0) then return (\emph{next\_inner\_corner} (s, s\_len, i, j+1))
  else if (j = length (s[i])) then return (false)) /* s[i] is filled only with zeros, */
                                                  /* hence there are no more inner corners */
else false; /* no inner corners in s */

/* s should be a skew tableau */
/* (i,j) should be next\_inner\_corner (s, s\_len, 1, 1) */
\emph{jeu\_de\_taquin} (s, i, j) :=
/* we're not on the border */
if ((i > 1) and (j < length (s[i])) and (j <= length (s[i-1]))) then block ( 
  if (s[i][j+1] < s[i-1][j]) then block ( /* slide to the rigth */
    s[i][j] : s[i][j+1],
    s[i][j+1] : 0,
    return (\emph{jeu\_de\_taquin} (s, i, j+1)))
  else block ( /* slide below */
    s[i][j] : s[i-1][j],
    s[i-1][j] : 0,
    return (\emph{jeu\_de\_taquin} (s, i-1, j))))
else if (((i > 1) and (j = length (s[i])) and /* outside corner */
        (j > length (s[i-1]))) or ((i = 1) and (j = length (s[1])))) then block (
  s[i] : rest (s[i], -1),
  if (emptyp (s[i])) then s : delete ([], s),
  return (s))
else if ((i > 1) and (j = length (s[i])) and (j = length (s[i-1]))) then block (
  s[i][j] : s[i-1][j],
  s[i-1][j] : 0,
  return (\emph{jeu\_de\_taquin} (s, i-1, j)))
else if ((i = 1) and (j < length (s[1]))) then block (
  s[1][j] : s[1][j+1],
  s[1][j+1] : 0,
  return (\emph{jeu\_de\_taquin} (s, 1, j+1)))
else if ((i > 1) and (j > length (s[i-1]))) then block (
  s[i] : append (makelist (s[i][k], k, 1, j-1), makelist (s[i][k], k, j+1, length (s[i]))),
  if (emptyp (s[i])) then s : delete ([], s),
  return (s));

/* s should be a skew tableau word */
rect (s) := block (
  [corner],
  corner : \emph{next\_inner\_corner} (s, length (s), 1, 1),
  if (corner = false) then return (s)
  else return (rect (\emph{jeu\_de\_taquin} (s, corner[1], corner[2]))));

/* t and u should be tableau words */
\emph{prod\_rect\_word} (t, u) := block (
  [t\_width, u\_height, zeros],
  t\_width : length (last (t)),
  u\_height : length (u),
  zeros : makelist (0, i, 1, t_width),
  return (rect (append (t, map (lambda ([x], append (zeros, x)), u))))); 

\emph{ytableaux\_product} (T,U) := block (
  R : new (ytableau (copylist (T@word))), /* we return a new tableau R = T*U */
  for i : 1 thru length (U@word) do
  for j : 1 thru length (U@word[i]) do \emph{ytableau\_bump} (R, U@word[i][j]),
  return (R));

/* The transpose of a tableau need not to be a tableau, so we're */
/* using simple lists instead of tableaux. Input list should be */
/* a list of lists. */
/* l should be [] */
\emph{remove\_tableau\_column} (t, l) :=
if emptyp (t) then return (l)
else block (
  [current\_line, next\_t],
  current\_line : reverse (maplist (lambda ([x], first (x)), t)),
  next\_t : maplist (lambda ([x], rest (x, 1)), t),
  next\_t : delete ([], next_t),
  return (\emph{remove\_tableau\_column} (next\_t, append ([current\_line], l))));

\emph{ytableau\_transpose} (T) := \emph{remove\_tableau\_column} (T@word, []); 
\end{alltt}
\small

\subsection*{yschur.mac}
\begin{alltt}
\footnotesize
/* given a tableau T returns */
/* the corresponding Schur monomial */
\emph{yschur\_monomial} (T) := block (
  [mon],
  mon : 1,
  for i : 1 thru length (T@word) do block (
    for j : 1 thru length ((T@word)[i]) do block (
      mon : mon*x[(T@word[i])[j]])),
  return (mon)); 

\emph{yschur\_monomial\_word} (w) := block (
  [mon],
  mon : 1,
  for i : 1 thru length (w) do block (
    for j : 1 thru length (w[i]) do block (
      mon : mon*x[(w[i])[j]])),
  return (mon));

/* i think this could be the best choice, provided a flatten word */
\emph{yschur\_monomial\_word\_recursive} (flat\_w, mon, i) := block (
  [x],
  if i > 0 then return (\emph{yschur\_monomial\_word\_recursive} (flat\_w, mon*x[flat\_w[i]], i-1))
  else return (mon));

/* Given a young diagram D and an alphabet {1,...,m} returns the */
/* corresponding Schur polynomial */
/* naive version */
\emph{yschur\_polynomial} (D, m) := block (
  [pol,n,w,t],
  pol : 0,
  n : \emph{ydiagram\_size} (D),
  lang\_size : m\^n,
  w : makelist (1, n),
  for i : 1 thru lang\_size do block (
    t : \emph{new\_ytableau\_safe} (w),
    if \emph{yshapep} (t,D) then block (
      pol : pol + \emph{yschur\_monomial}(t)),
    w : \emph{next\_lex\_word} (w, n, m)),
  return (pol));

/* better one */
\emph{last\_or\_zero} (l) := if emptyp (l) then 0 else last(l);

\emph{fill\_line} (len, m, ls) := block (
  [],
  if (len = 0) then return (map (lambda ([x], [x]), ls))
  else block (
    ls : xreduce ('append,
      makelist (makelist (
        append (x, [y]), y, \emph{last\_or\_zero} (x) + 1, m - len + 1), x, ls)),
    return (\emph{fill\_line} (len - 1, m, ls))));

/* flatten version of fill\_line */
\emph{fl\_fill\_line} (len, m, ls) :=
if len = 0 then ls
else \emph{fl\_fill\_line} (len - 1, m,
  xreduce ('append, makelist (
    makelist (append (x, [y]), y, \emph{last\_or\_zero} (x) + 1, m - len +1), x, ls)));

\emph{fill\_next\_line} (len, m, prev, ls) := block (
  [],
  if (len = 0) then return (ls)
  else block (
    [p],
    p : [],
    for x in ls do p : append (p,
      makelist (append (x, [y]), y, 
        max (\emph{last\_or\_zero} (x) + 1, prev[length (x)+1]), m - len + 1)),
    return (\emph{fill\_next\_line} (len - 1, m, prev, p))));

/* shape should be rows of Young diagram, actually the conjugate of the diagram */
/* we are trying to fill list in reversed order */
/* level should be 0, it is the last level filled. */
/* ts should be [[]], m is the size of the alphabet. */
\emph{list\_transposed\_ytableaux} (shape, level, m, ts) := block (
  [],
  if (level = length (shape)) then return (ts)
  else block (
    [],
    if (level = 0) then return (\emph{list\_transposed\_ytableaux} (shape, level + 1, m, 
      \emph{fill\_line} (shape[level + 1], m, ts)))
    else block (
      [ts\_first, nls, nts],
      if emptyp (flatten (ts)) then return ([]),
      ts\_first : first (ts),
      ts : delete (ts\_first, ts),
      nls : \emph{fill\_next\_line} (shape [level+1], m, first (ts_first), [[]]),
      nts : map (lambda ([x], append ([x], ts\_first)), nls),
      ts : append (ts, nts),
      if every (lambda ([x], 
        is (length (flatten (x)) = length (flatten (first (ts))))), ts) then level : (level + 1),
      return (\emph{list\_transposed\_ytableaux} (shape, level, m, ts)))));

/* flatten version */
\emph{fl\_list\_transposed\_ytableaux} (shape, level, m, ts) :=
if level < length (shape) then
if level > 0 then
if not emptyp (flatten (ts)) then block (
  [nls,ts\_first],
  ts\_first : first (ts),
  ts : delete (ts\_first, ts),
  nls : \emph{fill\_next\_line} (shape [level+1], m, 
    rest (ts\_first, - length (ts_first) + shape[level]), [[]]),
  ts : append (ts, map (lambda ([x], append (x, ts_first)), nls)),
  if every (lambda ([x], 
    is (length (flatten (x)) = length (flatten (first (ts))))), ts) then level : (level + 1),
  \emph{fl\_list\_transposed\_ytableaux} (shape, level, m, ts)) else []
else \emph{fl\_list\_transposed\_ytableaux} (shape, 
  level + 1, m, \emph{fl\_fill\_line} (shape[level + 1], m, ts))
else ts;

\emph{fl\_better\_yschur\_polynomial} (d, m) := block (
  [ts, pol, shape],
  d : \emph{new\_ydiagram\_safe} (d),
  shape : reverse ((\emph{ydiagram\_transpose} (d))@rows),
  print (shape),
  ts : \emph{fl\_list\_transposed\_ytableaux} (shape, 0, m, [[]]),
  pol : 0,
  for i : 1 thru length (ts) do 
    pol : pol + \emph{yschur\_monomial\_word\_recursive} (ts[i], 1, length (ts[i])),
  return (pol));
\end{alltt}
\small

\subsection*{LittlewoodRichardson.mac}
\begin{alltt}
\footnotesize
/* We should check that the three diagrams are suitable for Littlewood Richardson */
/* rev\_big\_shape, rev\_small\_shape are reversed words of diagrams */
/* gen\_skew\_tab should be [], and curr should be 1 */
\emph{generic\_skew\_tableau} (rev\_big\_shape, rev\_small\_shape, gen\_skew\_tab, curr) := block (
  [],
  if curr <= length (rev\_small\_shape) then block (
    [empty\_box,zeros,infs,current\_line],
    empty\_box : rev\_small\_shape[curr],
    zeros : makelist (0, empty\_box),
    infs : makelist (inf, rev\_big\_shape[curr] - empty\_box),
    current\_line : [append (zeros, infs)],
    return (\emph{generic\_skew\_tableau} (rev\_big\_shape, 
      rev\_small\_shape, append (current\_line, gen\_skew\_tab), curr + 1)))
  else if curr <= length (rev\_big\_shape) then block (
    [current\_line],
    current\_line : [makelist (inf, rev\_big\_shape[curr])],
    return (\emph{generic\_skew\_tableau} (rev\_big\_shape,
      rev\_small\_shape, append (current\_line, gen\_skew\_tab), curr + 1)))
  else return (gen\_skew\_tab));

/* st should be a transposed generic skew tableau, fst should be [] and level should be 1. */
\emph{fill\_first\_line} (st, u) := block (
  [filled\_skew\_tableau, ones],
  filled\_skew\_tableau : copylist (st),
  ones : lsum (i, i, map (lambda ([x], x[1] : x[1]/inf), filled\_skew\_tableau)),
  /* we should check if there are enough ones in the content u to fill the first column! */
  if ones <= u[1] then return ([filled\_skew\_tableau, ones]) else return ([]));

\emph{reverse\_lattice\_word\_condition} (u, u\_ins, try) :=
if (try > 1) and (u[try] > u\_ins[try]) and (u\_ins[try] + 1 <= u\_ins [try-1]) then true
else if (try = 1) and (u[1] > u\_ins[1]) then true
else false;

/* u\_len should be length (u) */
\emph{young\_tableau\_condition} (curr, u\_len, i, j, try) :=
if ((i>1) and (length(curr[i-1])>=j) and (try<=curr[i-1][j])) or 
   ((i>1) and (length(curr[i-1])<j)) or (i=1) then block (
  if (j>1) and (i<length(curr)) and (curr[i][j-1]<try) and 
     (try<=u_len-length(curr[i])+j) then true
  else if (j=1) and (i<length(curr)) and
          (try<u_len-length(curr[i])+j) then true
  else if (j>1) and (i=length(curr)) and
          (curr[i][j-1]<try) and (try<=u\_len-length(curr[i])+j) then true
  else false)
else false;

/* try should be 1 */
/* nextl should be [] */
/* curr[i][j] is empty, we should check this before calling next\_element */
\emph{next\_element} (curr, u, u\_ins, i, j, try, nextl) :=
if (try <= length (u)) then block (
  [],
  if \emph{reverse\_lattice\_word\_condition} (u, u\_ins, try) and
     \emph{young\_tableau\_condition} (curr, length (u), i, j, try) then block (
    [nexte, next\_u\_ins],
    nexte : copylist (curr),
    next\_u\_ins : copylist (u\_ins),
    nexte[i][j] : try,
    next\_u\_ins[try] : next\_u\_ins[try] + 1,
    return (\emph{next\_element} (curr, u, u_ins, i, j, try + 1, 
      append (nextl, [[nexte, next\_u\_ins]]))))
  else return (\emph{next\_element} (curr, u, u\_ins, i, j, try + 1, nextl)))
else return (nextl); 

/* Returns a list containing the list of Littlewood-Richardson skew tableaux */
/* with a given shape d/e and a given content u (i.e. Littlewood-Richardson number) */
/* Actually d,e,u will be reversed words of transposed tableaux */
/* d,e are reversed words of diagram, */
/* u is a reversed words of a diagram with u[1]-(second (generic\_skew\_tableau (d, e, [], 1), [])) */
/* u\_ins keeps track of which and how many letters have been used,*/
/* should be makelist (0, length (u)) */
/* st should be the transposed generic skew tableau with first line filled with ones */
/* i.e. fill\_first\_line (remove\_tableau\_column (first (generic\_skew\_tableau (d, e, [], 1), []))) */
/* tl is the tableaux list, should be [[st, u\_ins]] */
/* i,j are index to move around the skew tableau like in a matrix, i sould be 1 and j 2 */
/* This function should be called only if fill\_first\_line returns non empty list. */
\emph{littlewood\_richardson\_num} (d, e, u, tl, i, j) := block (
  [],
  if (not emptyp (tl)) and (i <= length (tl[1][1]))then block (
    [curr],
    curr : first (tl), /* curr[1] is a skew tableau, curr[2] is the crresponding u\_ins */
    if (j <= length (curr[1][i])) then block (
      [],
      if (curr[1][i][j] # inf) then return (\emph{littlewood\_richardson\_num} (d, e, u, tl, i, j+1))
      else block (
        [next\_l],
        tl : delete (curr, tl),
        next\_l : \emph{next\_element} (curr[1], u, curr[2], i, j, 1, []),
        tl : append (tl, next\_l),
        return (\emph{littlewood\_richardson\_num} (d, e, u, tl, i, j))))
    else return (\emph{littlewood\_richardson\_num} (d, e, u, tl, i+1, 1)))
  else return (tl));
\end{alltt}
\normalsize
