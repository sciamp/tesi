\begin{alltt}
\emph{generic\_skew\_tableau} (rev\_big\_shape,
                      rev\_small\_shape,
                      gen\_skew\_tab, curr) := block (
  [],
  if curr <= length (rev\_small\_shape) then block (
    [empty\_box,zeros,infs,current\_line],
    empty\_box : rev\_small\_shape[curr],
    zeros : makelist (0, empty\_box),
    infs : makelist (inf, rev\_big\_shape[curr] - empty\_box),
    current\_line : [append (zeros, infs)],
    return (\emph{generic\_skew\_tableau} (rev\_big\_shape,
                                  rev\_small\_shape,
                                  append (current\_line, gen\_skew\_tab),
                                  curr + 1)))
  else if curr <= length (rev\_big\_shape) then block (
    [current\_line],
    current\_line : [makelist (inf, rev\_big\_shape[curr])],
    return (\emph{generic\_skew\_tableau} (rev\_big\_shape,
                                  rev\_small\_shape,
                                  append (current\_line, gen\_skew\_tab),
                                  curr + 1)))
  else return (gen\_skew\_tab));

\emph{fill\_first\_line} (st, u) := block (
  [filled\_skew\_tableau, ones],
  filled\_skew\_tableau : copylist (st),
  ones : lsum (i, i, map (lambda ([x], x[1] : x[1]/inf),
               filled\_skew\_tableau)),
  if ones <= u[1] then return ([filled\_skew\_tableau, ones]) else return ([]));

\emph{reverse\_lattice\_word\_condition} (u, u\_ins, try) :=
if (try > 1) and
   (u[try] > u\_ins[try]) and
   (u\_ins[try] + 1 <= u\_ins [try-1]) then true
else if (try = 1) and (u[1] > u\_ins[1]) then true
else false;

\emph{young\_tableau\_condition} (curr, u\_len, i, j, try) :=
if ((i>1) and (length(curr[i-1])>=j) and (try<=curr[i-1][j])) or
   ((i>1) and (length(curr[i-1])<j)) or (i=1) then block (
  if (j>1) and (i<length(curr)) and (curr[i][j-1]<try) and
     (try<=u\_len-length(curr[i])+j) then true
  else if (j=1) and (i<length(curr)) and
          (try<u\_len-length(curr[i])+j) then true
  else if (j>1) and (i=length(curr)) and (curr[i][j-1]<try) and
          (try<=u\_len-length(curr[i])+j) then true
  else false)
else false;

\emph{next\_element} (curr, u, u\_ins, i, j, try, nextl) :=
if (try <= length (u)) then block (
  [],
  if \emph{reverse\_lattice\_word\_condition} (u, u\_ins, try) and
     \emph{young\_tableau\_condition} (curr, length (u), i, j, try) then block (
    [nexte, next\_u\_ins],
    nexte : copylist (curr),
    next\_u\_ins : copylist (u\_ins),
    nexte[i][j] : try,
    next\_u\_ins[try] : next\_u\_ins[try] + 1,
    return (\emph{next\_element} (curr, u, u\_ins, i, j, try + 1,
                          append (nextl, [[nexte, next\_u\_ins]]))))
  else return (\emph{next\_element} (curr, u, u\_ins, i, j, try + 1, nextl)))
else return (nextl); 

\emph{littlewood\_richardson\_num} (d, e, u, tl, i, j) := block (
  [],
  if (not emptyp (tl)) and (i <= length (tl[1][1]))then block (
    [curr],
    curr : first (tl),
    if (j <= length (curr[1][i])) then block (
      [],
      if (curr[1][i][j] # inf) then
         return (\emph{littlewood\_richardson\_num} (d, e, u, tl, i, j+1))
      else block (
        [next\_l],
        tl : delete (curr, tl),
        next\_l : \emph{next\_element} (curr[1], u, curr[2], i, j, 1, []),
        tl : append (tl, next\_l),
        return (\emph{littlewood\_richardson\_num} (d, e, u, tl, i, j))))
    else return (\emph{littlewood\_richardson\_num} (d, e, u, tl, i+1, 1)))
  else return (tl));
\end{alltt}
