\chapter{Polinomi di Schur}

\begin{defn}[Polinomio di Schur]
Data una partizione $\lambda \vdash n$ (i.e. un diagramma di Young
$\lambda = (n_1, \ldots, n_m)$) in $m$ parti (e quindi il diagramma ha
$m$ righe) e un qualunque tableau $T$ che riempie $\lambda$ indichiamo
con $x^T = \prod\limits_{i = 1}^m x^{c(i)}$, dove $c(i)$ \`e il numero
di volte che l'entrata $i$ compare nel tableau $T$. Sommando al variare di
$T$ fra i possibili riempimenti di $\lambda$ otteniamo
\begin{math}
s_\lambda(x_1,\ldots,x_m) = \sum x^T
\end{math}
che chiameremo polinomio di Schur.
\end{defn}
I polinomi di Schur sono simmetrici e costituiscono una base
dell'anello dei polinomi simmetrici.
\section{Anello dei tableau}

Sia $W_{[m]}$ l'insieme delle parole sull'alfabeto $[m]=\{1,\ldots,m\}$ e sia
$\sim_K$ la relazione di Knuth-equivalenza. $M_{[m]} =
\frac{W_{[m]}}{\sim_K}$ \`e l'insieme delle classi di equivalenza,
definiamo in $M_{[m]}$ un'operazione di prodotto attraverso la giustapposizione di parole e
osserviamo che \`e ben definito, infatti se $v \sim_K v'$ e $u \sim_K
u'$ si ha $v \cdot u \sim_K v' \cdot u \sim_K v \cdot u'$. In
definitiva $(M, \cdot, \varnothing)$, dove $\varnothing$ \`e la
parola vuota, \`e un monoide che, per il
teorema \ref{knuth_equiv_word}, possiamo identificare con il monoide
dei tableaux.

Il monoide $M$ ha un anello associato (per i dettagli si veda ~\cite{lang2002algebra}) che chiameremo \emph{anello dei tableaux}, e indicheremo con
$R_{[m]}$ e che \`e uno $\mathbb{Z}$-modulo libero generato dai
tableaux ad entrate in $[m]$ con prodotto indotto dal prodotto di tableaux.
Resta quindi definito un omomorfismo
\begin{equation}
\begin{matrix}\label{ring_tab}
\psi: & R_{[m]} & \rightarrow  & \mathbb{Z}[x_1,\ldots,x_m]\\
& T      & \mapsto & \psi(T)=x^T
\end{matrix}
\end{equation}
Indichiamo con $S_\lambda[m] \in R_{[m]}$ la somma di tutti i tableaux
che riempiono il diagramma $\lambda$, allora
$\psi(S_\lambda[m])=s_\lambda(x_1,\ldots,x_m)$ \`e il polinomio di
Schur corrispondente alla partizione $\lambda$ con $m$ variabili.

\section{Implementazione dei polinomi di Schur}
Nella nostra implementazione possiamo determinare l'immagine tramite
\eqref{ring_tab} di un tableau con la funzione
\texttt{\emph{yschur\_monomial\_word\_recursive}}
\begin{alltt}
t:[7,6,8,4,7,7,2,4,5,6,1,1,2,5]
\emph{yschur\_monomial\_word\_recursive} (t, 1, length (t))
\(\rightarrow x\sb1\sp2 x\sb2\sp2 x\sb4\sp2 x\sb5\sp2 x\sb6\sp2 x\sb7\sp3 x\sb8\) 
\end{alltt} 
e la funzione \emph{fl\_better\_yschur\_polynomial} per calcolare il
polinomio di Schur associato ad una partizione. Ad esempio nel caso della partizione
$(2,3)$ con quattro indeterminate si ha\\
\texttt{\emph{fl\_better\_yschur\_polynomial} ([2,3], 4)}
che ci d\`a
\begin{align*}
&x_{3}^2\,x_{4}^3+x_{2}\,x_{3}\,x_{4}^3+x_{1}\,x_{3}\,x_{4}^3+x_{2}^2\,x_{4}^3+x_{1}\,x_{2}\,x_{4}^3+x_{1}^2\,x_{4}^3+x_{3}^3\,x_{4}^2+2\,x_{2}\,x_{3}^2\,x_{4}^2+2\,x_{1}\,x_{3}^2\,x_{4}^2+&\\
&+2\,x_{2}^2\,x_{3}\,x_{4}^2+3\,x_{1}\,x_{2}\,x_{3}\,x_{4}^2+2\,x_{1}^2\,x_{3}\,x_{4}^2+x_{2}^3\,x_{4}^2+2\,x_{1}\,x_{2}^2\,x_{4}^2+2\,x_{1}^2\,x_{2}\,x_{4}^2+x_{1}^3\,x_{4}^2+x_{2}\,x_{3}^3\,x_{4}+&\\
&+x_{1}\,x_{3}^3\,x_{4}+2\,x_{2}^2\,x_{3}^2\,x_{4}+3\,x_{1}\,x_{2}\,x_{3}^2\,x_{4}+2\,x_{1}^2\,x_{3}^2\,x_{4}+x_{2}^3\,x_{3}\,x_{4}+3\,x_{1}\,x_{2}^2\,x_{3}\,x_{4}+3\,x_{1}^2\,x_{2}\,x_{3}\,x_{4}+&\\
&+x_{1}^3\,x_{3}\,x_{4}+x_{1}\,x_{2}^3\,x_{4}+2\,x_{1}^2\,x_{2}^2\,x_{4}+x_{1}^3\,x_{2}\,x_{4}+x_{2}^2\,x_{3}^3+x_{1}\,x_{2}\,x_{3}^3+x_{1}^2\,x_{3}^3+x_{2}^3\,x_{3}^2+2\,x_{1}\,x_{2}^2\,x_{3}^2+&\\
&+2\,x_{1}^2\,x_{2}\,x_{3}^2+x_{1}^3\,x_{3}^2+x_{1}\,x_{2}^3\,x_{3}+2\,x_{1}^2\,x_{2}^2\,x_{3}+x_{1}^3\,x_{2}\,x_{3}+x_{1}^2\,x_{2}^3+x_{1}^3\,x_{2}^2
\end{align*}

Il cuore dell'algoritmo risiede nella funzione
\emph{fl\_list\_transposed\_ytableaux} che calcola tutti i
possibili tableaux su un dato diagramma $\lambda$. Dal momento che la
definizione \ref{ytab} pone una condizione
lungo le colonne pi\`u stringente della non decrescenza sulle
righe, calcoliamo i possibili riempimenti del diagramma coniugato
$\tilde{\lambda}$, cos\`i facendo gi\`a dalla prima riga (ovvero la
prima colonna di $\lambda$) riduciamo il numero di riempimenti da
provare.\\
Il riempimento della prima riga avviene da sinistra verso destra
attingendo da $[m]=\{1,\ldots, m\}$ in modo tale che se inseriamo $k \in
[m]$ in posizione $i$-esima, e la prima riga \`e lunga $l_1$, esistano
$k_1,\ldots,k_{l_1-1} \in [m]$ tutti maggiori di $k$. Generiamo quindi
una lista di possibili riempimenti della prima riga, ognuno dei quali
dar\`a luogo ad una lista di possibili riempimenti delle prime due
righe, e cos\`i via.\\ 
Naturalmente riempiendo la riga $j$-esima, alla
posizione $i$ dovremo scegliere $k \in [m]$ tale che esistano
$k_1,\ldots,k_{l_j-1} \in [m]$ tutti maggiori di $k$ e tutti non
minori dell'elemento in posizione $i$-esima della riga
$(j-1)$-esima.\\
Ottenuta infine la lista dei possibili tableaux su $\lambda$ la
funzione \emph{yschur\_monomial\_word\_recursive} calcola il
corrispondente monomio, la somma di questi monomi \`e il polinomio di
Schur cercato $s_\lambda(x_1,\ldots,x_m)$.

%% % Non sono sicuro di doverne parlare. Per ora lascio in sospeso.
%% \section{Corrispondenza di Robinson-Schensted-Knuth}\label{RSKcorr}
%% Data una parola $w=x_1\ldots x_r$ indichiamo con $P(w)$ l'\emph{unico} tableau con
%% parola Knuth-equivalente a $w$ (teorema \ref{knuth_equiv_word}). Un
%% modo per ottenede $P(w)$ data $w$ \`e la \emph{procedura canonica}
%% vista nel capitolo precedente. Mentre costruiamo il tableau $P(w)$
%% teniamo traccia delle posizioni in cui stiamo inserendo le lettere di
%% $w$ costruendo un'altra tabella $Q(w)$ della stessa forma di $P(w)$
%% inserendo $k$ in posizione $Q(w)^i_j$ ogniqualvolta inseriamo $x_k$
%% nella riga $i$-esima alla colonna $j$-esima del tableau $P(w)$. Dunque
%% se stiamo costruendo $P_k=P(x_1\ldots x_k)=P_{k-1} \gets x_k =
%% ((\ldots (\varnothing \gets x_1) \gets \ldots ) \gets x_{k-1} ) \gets
%% x_k$ inseriremo $k$ in $Q_k=Q(x_1 \ldots x_k)$ in corrispondenza della posizione
%% presente in $P_k$ ma non in $P_{k-1}$.

%% \begin{oss}
%% Ad ogni passo $1 \leq k \leq r$ della procedura canonica, $Q_k$ \`e un
%% tableau standard.
%% %% \begin{proof}
%% %% Chiaramente le entrate di $Q(w)$ sono tutte distinte fra loro essendo
%% %% indici delle lettere della parola $w$. Supponiamo che $Q_k$ sia un
%% %% tableau standard, si hanno tre casi:\\
%% %% $x_k < x_{k+1}$: \\
%% %% $x_k = x_{k+1}$:\\
%% %% $x_k > x_{k+1}$:\\
%% %% \end{proof}
%% \end{oss}

%% Essendo note le posizioni in cui sono state inserite le varie lettere,
%% da $(P(w),Q(w))$ possiamo ricostruire $w$, questo significa che data
%% una qualunque coppia di tableaux $(P,Q)$ che riempiono lo stesso
%% diagramma con $Q$ standard esiste una parola $\bar w$ tale che
%% $(P,Q)=(P(\bar w),Q(\bar w))$.

%% Abbiamo cos\`i una corrispondenza
%% biunivoca fra le parole $w$ di lunghezza $r$ con lettere
%% nell'alfabeto $[n]$ e le coppie $(P,Q)$ di tableaux riempimenti dello
%% stesso diagramma $\lambda \vdash r$ con $P$ ad entrate in $[n]$ e $Q$
%% standard. Nel caso particolare in cui $r=n$ e le lettere di $w$ siano
%% tutte diverse una dall'altra, ovvero $w \in S_n$, si ha che anche $P$
%% \`e uno standard tableau e viceversa.

%% \begin{notaz}[Vettore doppio]
%% Chiamiamo vettore doppio una matrice $2 \times n$. 
%% \end{notaz}

%% \begin{defn}
%% Un vettore doppio
%% \begin{math}
%% \begin{bmatrix}
%% u_1 & \ldots & u_m\\
%% v_1 & \ldots & v_m
%% \end{bmatrix}
%% \end{math}
%% si dice in ordine lessicografico se valgono:
%% \begin{enumerate}[(i)]
%% \item $u_1 \leq \ldots \leq u_n$;
%% \item $v_i \leq v_{i+1}$ se $u_1 = u_{i+1}$.
%% \end{enumerate}
%% \end{defn}

%% Knuth generalizz\`o (per i dettagli si veda ~\cite{fulton1997young})
%% la corrispondenza precedente ad una qualunque coppia di
%% tableau $(P,Q)$, che riempiono lo stesso diagramma, con $P$ ad entrate
%% in $[n]$ e $Q$ in $[m]$. In questo caso si ha la corrispondenza fra le
%% coppie $(P,Q)$ e i \emph{vettori doppi} in ordine lessicografico
%% \begin{math}
%% \begin{bmatrix}
%% u_1 & \ldots & u_m\\
%% v_1 & \ldots & v_m
%% \end{bmatrix}
%% \end{math}.
